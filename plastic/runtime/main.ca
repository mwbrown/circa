
-- Information about the current window (passed in from main.cpp)
type Window {
   int width
   int height
}

window = Window()

window_size = [window.width window.height]->Point

def random_location() -> Point
    "Return a random point that is inside the boundaries of the window."
    return [rand() * window.width, rand() * window.height]

-- ide - functions for controlling IDE behavior
namespace ide
    def script_filename() -> string
    def quit() "Tell the IDE to shutdown"
    def reset_state() "Reset state for the current script"
    def reload_runtime() "Reload the builtin runtime"
    def paused() -> bool "Returns whether the current script is paused"
    def get_time() -> number

time = ide:get_time()
time_delta = delta(time)
render_duration = 0.0
td = time_delta -- shorthand

-- Input
type Keypress {
    string character
    int code
    int modifier
}

def key_down_code(int key) -> bool
def key_down_char(string key) -> bool
key_down = overloaded_function(key_down_code key_down_char)
def key_pressed_code(int key) -> bool
def key_pressed_char(string key) -> bool
key_pressed = overloaded_function(key_pressed_code key_pressed_char)
def mouse_location() -> Point
def mouse_pressed() -> bool
def mouse_over(Rect region) -> bool
def recent_key_presses() -> List
def mouse_clicked_anywhere () -> bool
def mouse_clicked_region (Rect region) -> bool
mouse_clicked = overloaded_function(mouse_clicked_anywhere mouse_clicked_region)
def mouse_wheel_up_anywhere () -> bool
def mouse_wheel_up_region (Rect region) -> bool
mouse_wheel_up = overloaded_function(mouse_wheel_up_anywhere mouse_wheel_up_region)
def mouse_wheel_down_anywhere () -> bool
def mouse_wheel_down_region (Rect region) -> bool
mouse_wheel_down = overloaded_function(mouse_wheel_down_anywhere mouse_wheel_down_region)

-- Wrap up mouse position into a point (values are passed in from input.cpp)
mouse = mouse_location() -> Point

def mouse_in(Rect b) -> bool
  "Return whether the mouse is currently inside the given rect."
  return (b.x1 < mouse.x) and (b.x2 > mouse.x) and (b.y1 < mouse.y) and (b.y2 > mouse.y)

-- These values are assigned in input.cpp
namespace key
    up = 0
    down = 0
    left = 0
    right = 0
    space = 0
    delete = 0
    enter = 0
    escape = 0

-- Text rendering functions
type Font;

namespace sdl_ttf
    type RenderedText { int texid, int width, int height, Color color, string text }
    def load_font_internal(string filename, int size) -> Font
    def load_font(string filename, int size) -> Font
        "Load the given font"
        state Font s
        if changed(filename) or changed(size)
            s = load_font_internal(filename,size)
        return s

    def render_text_internal(Font font, string text, Color color) -> RenderedText
    def render_text(Font font, string text, Color color) -> RenderedText
        "Render text and return a sprite that can be drawn with draw_rendered_text. This is useful if you want to know the width or height of the rendered text before drawing it."
        state RenderedText s
        if changed(font) or changed(text) or changed(color)
            s = render_text_internal(font, text, color)
        return s
    def draw_rendered_text(RenderedText, Point loc)
        "Draw a sprite created with render_text."
    def get_metrics(Font font, string text) -> Point;

def draw_text(Font font, string str, Color color, Point location) -> Rect
    "Render and draw a string."
    sprite = sdl_ttf:render_text(font, str, color)
    sdl_ttf:draw_rendered_text(sprite, location)
    return to_rect(location, [sprite.width sprite.height])

def draw_text_centered(Font font, string str, Color color, Point location)
    sprite = sdl_ttf:render_text(font, str, color)
    sdl_ttf:draw_rendered_text(sprite, [location.x - sprite.width/2 location.y])

-- GL functions
def background(Color) "Fill the screen with the given color."

namespace gl
    def triangles(List, Color) "Render a list of points as triangles."
    def line_strip(List, Color) "Render a list of points as a line strip."
    def line_loop(List, Color) "Render a list of points as a line loop."
    def lines(List, Color) "Render a list of points as a line list."
    def points(List, Color) "Render a list of points."
    def circle(Point loc, number radius, Color) "Render a circle."
    def pie(Point loc, number radius, number angle_start, number angle_fin, Color)
        "Render a pie slice."

-- Audio
type Sound;
def load_sound_int(string filename) -> Sound
def play_sound(Sound sound, number freq);

def load_sound(string filename) -> Sound
    state Sound s
    if changed(filename)
        s = load_sound_int(filename)
    return s

def delta_point(Point p) -> Point
    state Point prev = p
    result = p - prev
    prev = p
    return result

-- Drawing utils
include(rpath('vector_drawing.ca'))

-- Time-based stateful functions
def alternate_over_time(number period) -> bool
    "Stateful function, alternates between true and false according to the given period."
    state number time_started = time
    return round((time - time_started) / period) % 2 == 0

def linear_fadein(number total_time) -> number
    <<<
    Stateful function, starts out at 0 and increases linearly. After 'total_time'
    has passed, it will return 1.0 and stay there.
    >>>
    state number time_started = time
    elapsed = (time - time_started) / total_time
    return min(elapsed, 1.0)

def elapsed() -> number
    "Stateful function, returns the number of seconds that has passed since this function was first called"
    state number time_started = time
    return time - time_started

def every(number seconds) -> bool
    "Stateful function, returns true once every 'seconds'"
    state time_remaining = seconds
    time_remaining -= time_delta
    if time_remaining < 0
        time_remaining += seconds
        return true
    else
        return false

def draggable_rect(Point initial_location, Point size) -> Point
    state Point location = initial_location
    rect = [location.x, location.y, location.x+size.x, location.y+size.y]
    state currently_dragging = false
    state Point mouse_offset = [0 0]
    if currently_dragging
        location = (mouse + mouse_offset) -> Point
        if not(mouse_pressed())
            currently_dragging = false
    elif mouse_clicked(rect)
        currently_dragging = true
        mouse_offset = location - mouse
    return location

ui_font_medium = sdl_ttf:load_font("../assets/sv_basic_manual/SVBasicManual.ttf"->rpath, 16)
coding_font = sdl_ttf:load_font("../assets/Inconsolata.otf"->rpath, 16)

namespace fps_counter
    state int framesElapsed = 0
    state number timeStarted = time
    state number lastRecoredFps = 0

    framesPerSample = 30
    earlySampleTime = .5

    framesElapsed += 1
    timeElapsed = time - timeStarted

    if (framesElapsed > framesPerSample) or (timeElapsed > earlySampleTime)
        lastRecoredFps = framesElapsed / timeElapsed
        framesElapsed = 0
        timeStarted = time

fps = fps_counter:lastRecoredFps


namespace tweak
    def button(Ref r, Point loc, string name)
        "Draw a button which displays the value of 'r', allowing the user to tweak that value using mouse input."
        str = concat(name ' = ' r.to_string())

        text_sprite = sdl_ttf:render_text(ui_font_medium, str, #000)
        padding = 3.0
        rect = [loc.x - padding, loc.y - padding,
            loc.x + text_sprite.width + padding,
            loc.y + text_sprite.height + padding]
        color = #ee3399
        if mouse_in(rect) { color = #ff44aa }
        fill_rect(rect, color)
        sdl_ttf:draw_rendered_text(text_sprite, [loc.x loc.y])

        -- mouse wheel
        if mouse_wheel_up(rect)
            r.tweak(-1)
        elif mouse_wheel_down(rect)
            r.tweak(1)

        -- click and drag
        state mouse_dragging = false
        state Point mouse_drag_previous_point = [0 0]
        if mouse_clicked(rect)
            mouse_dragging = true
            mouse_drag_previous_point = mouse
        elif not(mouse_pressed())
            mouse_dragging = false

        if mouse_dragging
            delta = (mouse - mouse_drag_previous_point) -> Point
            mouse_drag_previous_point = mouse
            steps = round(delta.y)
            r.tweak(steps)

-- Support for postprocess operations using FBOs
namespace postprocess
    type Surface {
        int tex_id
        int fbo_id
        int width
        int height
    }

    def make_surface(state Surface _state, Point size) -> Surface
    def bind_surface(Surface surface)
    def draw_surface(Surface source)
    def draw_surface_at(Surface source, Rect rect)
    def copy_surface(Surface source, Surface dest)

    main_surface = [0 0 window.width window.height] -> Surface

    def bind_main_surface() bind_surface(main_surface)

-- Include other runtime scripts
include('../../libs/box2d/box2d.ca' -> rpath)
include('../../libs/opengl/opengl.ca' -> rpath)
include('../../libs/osc/osc.ca' -> rpath)
include('../../libs/sdl_img/sdl_img.ca' -> rpath)
include('../../libs/imagemanip/imagemanip.ca' -> rpath)

-- cairo.ca depends on opengl
include('../../libs/cairo/cairo.ca' -> rpath)

include('text_input.ca' -> rpath)
include('ui_widgets.ca' -> rpath)

def draw_image(string filename, Point location)
    sdl_img:draw_image(filename, location)

-- Load the user's script
initial_filename = ide:script_filename()
cond(initial_filename == "", "../../demos/demo_browser.ca"->rpath, @initial_filename)
state string user_script_filename = ide:script_filename()

-- Function to specify a different script
def load_user_script(string filename)
    send('load_user_script_request', filename)
receive_last('load_user_script_request' @user_script_filename)

users_script = load_script(user_script_filename)

if users_script.has_static_error()
    draw_image("../assets/Ferry_Boat_Sinking.jpg"->rpath, [0 0])
    errs = users_script.get_static_errors_formatted()
    image_height = 365
    image_width = 550
    text_area_height = 17 * (errs.count() + 1) + 15
    fill_rect([0 image_height window.width image_height+text_area_height] #733)
    y = image_height + 10
    draw_text(ui_font_medium, "Static errors:", #fff, [5 y])
    y += 17
    for err in errs
        draw_text(ui_font_medium err #fff [15 y])
        y += 17

    if once()
        print(errs)
else
    ev = users_script.evaluate()

    if errored(ev)
        print(ev)

--include('overlay.ca' -> rpath)
